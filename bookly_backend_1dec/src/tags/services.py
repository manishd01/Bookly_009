
from sqlmodel.ext.asyncio.session import AsyncSession
from src.db.model import Tag,Book, BookTag
from sqlmodel import select, desc
from .schema import *
from src.books.service import BookService
from fastapi.exceptions import HTTPException
from fastapi import status
from src.errors import BookNotFound, TagNotFound, TagAlreadyExists

book_service = BookService()

class TagService:
    async def get_tags_by_book(
        self,
        book_uid: str,
        session: AsyncSession,
    ):
            result = await session.exec(
                select(Book).where(Book.uid == book_uid)
            )
            book = result.one_or_none()

            if not book:
                raise BookNotFound()

            # ðŸ‘‡ ORM magic: uses BookTag automatically
            return book.tags
    
    async def get_tags(self, session :  AsyncSession):
        statement = select(Tag).order_by(desc(Tag.created_at))
        resultt=await session.exec(statement)
        return resultt.all()
    
    # # imp functionL--------
    # async def add_tags_to_Book( self, book_uid : str, tag_data : TagCreateModel, session : AsyncSession):
    #     book = await book_service.get_a_book(book_uid = book_uid, session=session )
    #     # if not book: 
    #         # raise ValueError("Book NOt founddd") #another mehtod:
    #         # raise BookNotFound()
    #     if not book:
    #         raise BookNotFound() #

    #     for tag_item in tag_data.tags:
    #         result = await session.exec(select(Tag).where(Tag.name ==  tag_item.name))
    #         tag = result.one_or_none()
    #         if not tag:
    #             tag = Tag(name = tag_item.name)
            
    #         book.tags.append(tag)
        
    #     session.add(book)
    #     await session.commit()
    #     await session.refresh(book)
    #     return book 

    async def add_tags_to_Book(
    self,
    book_uid: str,
    tag_data: TagCreateModel,
    session: AsyncSession,
):
        # ðŸ”¹ 1. Fetch book
        book = await book_service.get_a_book(
            book_uid=book_uid,
            session=session,
        )

        if not book:
            raise BookNotFound()

        # ðŸ”¹ 2. Check if tag already exists
        result = await session.exec(
            select(Tag).where(Tag.name == tag_data.name)
        )
        tag = result.one_or_none()

        # ðŸ”¹ 3. Create tag if it does not exist
        if not tag:
            tag = Tag(name=tag_data.name)
            session.add(tag)
            await session.flush()  # ensures tag.uid is generated

        # ðŸ”¹ 4. Attach tag to book
        # ðŸ‘‰ THIS LINE creates a row in `booktags`
        if tag not in book.tags:
            book.tags.append(tag)

        # ðŸ”¹ 5. Save
        session.add(book)
        await session.commit()
        await session.refresh(book)

        return book


    async def add_tag(self,tag_data: TagCreateModel, session : AsyncSession):
        statement =  select(Tag).where(Tag.name == tag_data.name)
        result = await session.exec(statement)
        tag = result.first()

        if(tag):
            # raise ValueError("tag already exists")
            raise TagAlreadyExists()
        
        new_tag = Tag(name = tag_data.name)
        # session.add(new_tag.name)

        session.add(new_tag)
        await session.commit()
        # //imp check
        await session.refresh(new_tag)  # Refresh to load autogenerated fields like uid or created_at

        return new_tag

    async def get_tag_by_ID(self,tag_uid:  str, session: AsyncSession):
        statement = select(Tag).where (Tag.uid == tag_uid)
        ress= await session.exec(statement)
        return ress.first()


    async def update_tag(self, tag_uid, tag_update_data : TagCreateModel, session: AsyncSession):
        tag = await self.get_tag_by_ID(tag_uid, session)
        if not tag :
            # raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)
            raise TagNotFound()
        
        update_data_dict = tag_update_data.model_dump()

        for k,v in update_data_dict.items():
            setattr(tag,k,v)
            await session.commit()
            await session.refresh(tag)
        
        return tag

    async def delete_tag(self, tag_uid :  str, session : AsyncSession):
        tag = await self.get_tag_by_ID(tag_uid, session)
        if not tag:
            # raise ValueError("TagNotFound()....")
            raise TagNotFound()
        
        await session.delete(tag)
        await session.commit()

    
